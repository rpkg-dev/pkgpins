# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/pkgpins.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literate programming approach used applying the R Markdown format.

# pkgpins: Facilitates Results Caching in R Packages Using the Pins Package
# Copyright (C) 2021 Salim Br√ºggemann
# 
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or any later version.
# 
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License along with this program. If not, see <https://www.gnu.org/licenses/>.

utils::globalVariables(names = c(".",
                                 "cached",
                                 "id",
                                 "name"))

#' Register a package's user-cache pins board
#'
#' This function registers a package's user-cache pins board. It will be automatically called when needed.
#'
#' @inheritParams boardname
#'
#' @return `boardname` invisibly if it wasn't registered before, otherwise `NULL`.
#' @export
#'
#' @examples
#' \dontrun{
#' # you could register the cache on package load, although this is not necessary in most cases
#' .onLoad <- function(libname, pkgname) {
#'   pkgpins::register(pkgname)
#' }}
register <- function(pkg) {
  
  if (!(boardname(pkg) %in% pins::board_list())) {
    
    pins::board_register_local(name = boardname(pkg),
                               cache = pins::board_cache_path(),
                               versions = FALSE)
  }
}

#' Deregister a package's user-cache pins board
#'
#' This function deregisters a package's user-cache pins board.
#'
#' Ideally, you call this function on [package unload][base::.onUnload]. See the examples for details.
#'
#' @inheritParams boardname
#'
#' @return `NULL`.
#' @export
#'
#' @examples
#' \dontrun{
#' # deregister the cache on package unload (recommended)
#' .onUnload <- function(libpath) {
#'   pkgpins::deregister()
#' }}
deregister <- function(pkg) {
  
  if (boardname(pkg) %in% pins::board_list()) {
    
    pins::board_deregister(name = boardname(pkg))
  }
}

#' Get a package's user-cache pins board name
#'
#' This function returns the board name of the `pks`'s user-cache pins board. 
#' 
#' It shouldn't be necessary to rely on this function for the tasks this package is intended to perform, though.
#'
#' @param pkg The package name. A character scalar.
#'
#' @return The board name of the [user-cache pins board](https://pins.rstudio.com/articles/boards-understanding.html) belonging to `pkg`, which is at the same
#'   time the name of the filesystem directory beneath [path_cache()]. A character scalar.
#' @export
#'
#' @examples
#' \donttest{
#' pkgpins::boardname(pkg = "not.a.real.pkg")}
boardname <- function(pkg) {
  
  paste0("pkg-cache-", checkmate::assert_string(pkg))
}

#' Get a package's user-cache pins board path
#'
#' This function allows to the determine the filesystem path to the `pkg`'s user-cache pins board. Note that this path depends on the operating system this
#' function is called from.
#' 
#' It shouldn't be necessary to rely on this function for the tasks this package is intended to perform, though.
#'
#' @inheritParams boardname
#'
#' @return A path of type [fs_path][fs::path()].
#' @export
#'
#' @examples
#' \donttest{
#' pkgpins::path_cache(pkg = "not.a.real.pkg")}
path_cache <- function(pkg) {
  
  fs::path(pins::board_cache_path(), boardname(pkg))
}

#' List all objects in a package's user-cache pins board
#'
#' This function lists all object `id`s belonging to a `pkg`'s user-cache pins board, together with the date and time they were `cached`.
#'
#' @inheritParams boardname
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#'
#' @examples
#' \donttest{
#' pkgpins::ls_cache(pkg = "not.a.real.pkg")}
ls_cache <- function(pkg) {
  
  register(pkg = pkg)
  result <- pins::pin_find(board = boardname(pkg),
                           extended = TRUE)
  
  if ("cached" %in% colnames(result)) {
    result %<>% dplyr::transmute(id = name,
                                 cached = lubridate::as_datetime(cached,
                                                                 tz = "UTC"))
  } else {
    result <- tibble::tibble(id = character(),
                             cached = lubridate::as_datetime(integer(),
                                                             tz = "UTC"))
  }
  
  result
}

#' Delete all objects from a package's user-cache pins board exceeding a certain age
#'
#' This function allows to clean up old caching left-overs. It could be called on package load/unload, for example.
#'
#' @inheritParams boardname
#' @param max_age The age above which cached objects will be deleted. A valid [lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours).
#'
#' @return The IDs of the deleted objects invisibly.
#' @export
#'
#' @examples
#' \dontrun{
#' # delete all cached results that are older than 7 days at once on package load:
#' .onLoad <- function(libname, pkgname) {
#'   pkgpins::clear(pkg = pkgname,
#'                  max_age = "7 days")
#' }}
clear <- function(pkg,
                  max_age = "1 day") {
  
  register(pkg = pkg)
  
  ls_cache(pkg) %>%
    dplyr::filter(lubridate::now(tzone = "UTC") - cached > lubridate::as.duration(max_age)) %$%
    id %>%
    purrr::walk(.f = pins::pin_remove,
                board = boardname(pkg))
}

#' Cache an object to a package's user-cache pins board
#'
#' This function stores an object in a package's user-cache pins board.
#' 
#' The exact date and time (UTC) of the pinning is stored as the additional metadata `cached` which is of type [integer][base::integer]. You can restore the
#' actual datetime using [`lubridate::as_datetime(cached, tz = "UTC")`][lubridate::as_datetime] (note that [ls_cache()] does this automatically).
#'
#' See [hash_fn_call()] for a convenient way to create an `id` that uniquely identifies a function call. Or just use [with_cache()].
#'
#' @inheritParams boardname
#' @param x An object, local file or remote URL to be cached.
#' @param id The pin name uniquely identifying `x` in the `pkg`'s user-cache pins board. A character scalar. Necessary to retrieve `x` again using
#'   [get_obj()]. An already existing pin named `id` will be silently overwritten.
#'
#' @return `x` invisibly.
#' @export
#'
#' @examples
#' \donttest{
#' library(magrittr)
#'
#' # if the fn below would be part of a real package, we could instead define `this_pkg`
#' # globally using `this_pkg <- utils::packageName()`
#' this_pkg <- "not.a.real.pkg"
#' 
#' # let's define a fn that returns R pkg sys deps from cache
#' pkg_sys_deps <- function(pkg,
#'                          use_cache = TRUE,
#'                          cache_lifespan = "6h") {
#'   fetch <- TRUE
#'
#'   if (use_cache) {
#'     pin_name <- pkgpins::hash_fn_call(pkg = this_pkg,
#'                                       from_fn = "pkg_sys_deps",
#'                                       pkg)
#'     result <- pkgpins::get_obj(id = pin_name,
#'                                max_age = cache_lifespan,
#'                                pkg = this_pkg)
#'     fetch <- is.null(result)
#'   }
#'   
#'   if (fetch) {
#'     result <-
#'       jsonlite::fromJSON(txt = paste0("https://sysreqs.r-hub.io/pkg/", pkg),
#'                          simplifyVector = FALSE) %>%
#'       purrr::flatten()
#'   }
#'  
#'   if (use_cache && fetch) {
#'     pkgpins::cache_obj(x = result,
#'                        id = pin_name,
#'                        pkg = this_pkg)
#'   }
#'
#'   result
#' }
#'
#' # now get the sys deps for git2r for the first time (populating the cache)
#' pkg_sys_deps("git2r")}
#'
#' \dontrun{
#' # for the `cache_lifespan` (we've set a default of 6h), the cached result will be returned
#' # (as long as `use_cache = TRUE`):
#' bench::mark("with cache" = pkg_sys_deps("git2r"),
#'             "without cache" = pkg_sys_deps("git2r", use_cache = FALSE),
#'             iterations = 10,
#'             relative = TRUE)}
cache_obj <- function(x,
                      id,
                      pkg) {
  
  checkmate::assert_string(id)
  register(pkg = pkg)
  
  pins::pin(x = I(x),
            board = boardname(pkg),
            name = id,
            metadata = list(cached = lubridate::now(tzone = "UTC")))
}

#' Get a cached object from a package's user-cache pins board
#'
#' This function retrieves a cached object from a package's user-cache pins board _if_ it is not older than `max_age`.
#'
#' @inheritParams boardname
#' @param id The pin name uniquely identifying the object to be retrieved from the `pkg`'s user-cache pins board. A character scalar.
#' @param max_age The maximum age the cached object is allowed to have. A valid [lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours).
#'
#' @return The cached object if it is not older than `max_age`, otherwise `NULL`.
#' @export
#'
#' @examples
#' \donttest{
#' pkgpins::get_obj(id = "something",
#'                  pkg = "some_pkg",
#'                  max_age = "2 weeks")}
get_obj <- function(id,
                    pkg,
                    max_age = "1 day") {
  
  checkmate::assert_string(id)
  register(pkg = pkg)
  board <- boardname(pkg)
  result <- pins::pin_find(name = id,
                           board = board,
                           extended = TRUE)
  
  if (nrow(result) > 1L) {
    rlang::abort(paste0("Multiple pins found for board '", board, "'!\nThis should not happen since versioning is disabled for pkgpins boards... \U1F41E"))
    
  } else if (nrow(result) == 1L) {
    
    if (!("cached" %in% colnames(result))) {
      rlang::abort(paste0("Corrupted package cache detected! Please delete the directory `", path_cache(pkg = pkg), "` and then try again."))
    }
    
    result %<>%
      dplyr::filter(lubridate::now(tzone = "UTC") - lubridate::as_datetime(cached, tz = "UTC") <= lubridate::as.duration(max_age)) %$%
      name
    
    if (length(result) > 0L) {
      result <- pins::pin_get(board = board,
                              name = id)
    } else{
      result <- NULL
    }
    
  } else {
    result <- NULL
  }
  
  result
}

#' Delete a cached object from a package's user-cache pins board
#'
#' Note that it normally won't be necessary to delete a cached object using this function because [cache_obj()] will always overwrite a possibly existing object
#' in the cache with the same `id`. If you want to ensure that no "data corpses" are left behind from using [cache_obj()], consider clearing the whole package
#' user-cache pins board at once using [clear()].
#'
#' @inheritParams boardname
#' @param id The pin name uniquely identifying the object to be deleted from the `pkg`'s user-cache pins board. A character scalar.
#'
#' @export
#'
#' @examples
#' \donttest{
#' pkgpins::rm_obj(id = "git2r-syreqs",
#'                 pkg = "not.a.real.pkg")}
rm_obj <- function(id,
                   pkg) {
  
  checkmate::assert_string(id)
  register(pkg = pkg)
  
  pins::pin_remove(board = boardname(pkg),
                   name = id)
}

#' Hash a function call
#'
#' Creates a string that uniquely identifies a function call by the function's namespace, name and a hash of the specified arguments.
#' 
#' `r foo <- function(a) pkgpins::hash_fn_call("mypkg", "foo", a); NULL`
#' 
#' This function does evaluate object names passed as function arguments. I.e. the function call `mypkg::foo(a = my_var)` will be cached as
#' `r pal::wrap_chr(foo(100))` if `my_var`'s value is `100`, whereas it will become `r pal::wrap_chr(foo(101))` if `my_var`'s value is `101`. See examples
#' below.
#'
#' @param from_fn The name of the function from which `hash_fn_call()` is called. A character scalar.
#' @param pkg The namespace `from_fn` belongs to, typically a package name. A character scalar.
#' @param ... The arguments `from_fn` was called with. Any arguments omitted here won't be taken into account when generating the hash.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' foo <- function(a, b = "default") pkgpins::hash_fn_call("mypkg", "foo", a, b)
#' 
#' foo("bar")
#' a <- "bar"
#' foo(a)
#' a <- "barbie"
#' foo(a)
#' a |> foo()
#' a |> foo(b = "default")
#' 
#' # you can also create a hash that is based on a subset of all function arguments
#' foo <- function(a, b = "default") pkgpins::hash_fn_call("mypkg", "foo", b)
#' 
#' foo("bar")
#' foo("barrr")
#' foo(b = "bar")
hash_fn_call <- function(pkg,
                         from_fn,
                         ...) {
  
  checkmate::assert_string(from_fn)
  checkmate::assert_string(pkg)
  
  rlang::dots_list(...,
                   .homonyms = "error",
                   .ignore_empty = "trailing",
                   .preserve_empty = FALSE,
                   .check_assign = TRUE) %>%
    rlang::hash() %>%
    paste(pkg, from_fn, .,
          sep = "-")
}

#' Cache the result of an expression from within a function
#'
#' One-stop solution to add caching to an R function.
#'
#' `expr` is evaluated in the environment that `with_cache()` is called from.
#'
#' See [hash_fn_call()] for details about how the pin name is constructed that uniquely identifies `expr` in the `pkg`'s user-cache pins board.
#'
#' @inheritParams boardname
#' @param expr The expression to cache.
#' @param from_fn The name of the function that `expr` is cached from, i.e. the name of the function that `with_cache()` is called from. A character scalar.
#' @param ... The arguments received by `from_fn` on which the caching should depend. This is fundamental to determine whether `expr` was already cached or not.
#' @param use_cache `r pkgsnip::param_label("use_cache")`
#' @param cache_lifespan `r pkgsnip::param_label("cache_lifespan")` 
#'
#' @return The result of evaluating `expr`, from cache if `use_cache = TRUE` and a cached result exists that hasn't exceeded `cache_lifespan`.
#' @export
#'
#' @examples
#' # if the fn below would be part of a real package, we could instead define `this_pkg`
#' # globally using `this_pkg <- utils::packageName()`
#' this_pkg <- "not.a.real.pkg"
#' 
#' # let's define a fn that returns R pkg sys deps from cache
#' pkg_sys_deps <- function(pkg,
#'                          use_cache = TRUE,
#'                          cache_lifespan = "6h") {
#'   pkgpins::with_cache(
#'     expr = purrr::flatten(jsonlite::fromJSON(txt = paste0("https://sysreqs.r-hub.io/pkg/", pkg),
#'                                              simplifyVector = FALSE)),
#'     from_fn = "pkg_sys_deps",
#'     pkg,
#'     use_cache = use_cache,
#'     cache_lifespan = cache_lifespan,
#'     pkg = this_pkg
#'   )
#' }
#' 
#' # now get the sys deps for git2r for the first time (populating the cache)
#' pkg_sys_deps("git2r")
#' 
#' \dontrun{
#' # for the `cache_lifespan` (we've set a default of 6h), the cached result will be returned
#' # (as long as `use_cache = TRUE`):
#' bench::mark("with cache" = pkg_sys_deps("git2r"),
#'             "without cache" = pkg_sys_deps("git2r", use_cache = FALSE),
#'             iterations = 10,
#'             relative = TRUE)}
with_cache <- function(expr,
                       pkg,
                       from_fn,
                       ...,
                       use_cache = TRUE,
                       cache_lifespan = "1 day") {
  
  checkmate::assert_flag(use_cache)
  fetch <- TRUE
  
  if (use_cache) {
    
    id <- hash_fn_call(from_fn = from_fn,
                       pkg = pkg,
                       ...)
    
    result <- get_obj(id = id,
                      max_age = cache_lifespan,
                      pkg = pkg)
    
    fetch <- is.null(result)
  }
  
  if (fetch) {
    result <- rlang::eval_bare(expr = expr,
                               env = parent.frame(n = 2L))
  }
  
  if (use_cache && fetch) {
    
    cache_obj(result,
              id = id,
              pkg = pkg)
  }
  
  result
}
