% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkgpins.gen.R
\name{cache_obj}
\alias{cache_obj}
\title{Cache an object to a package's user-cache pins board}
\usage{
cache_obj(board, x, id, qs_preset = c("fast", "balanced", "high", "archive"))
}
\arguments{
\item{board}{\link[=board]{Package's user-cache pins board}.}

\item{x}{Object to be cached.}

\item{id}{Pin name uniquely identifying \code{x} in the \code{pkg}'s user-cache pins board. A character scalar which is safe to use in paths of common file systems.
Necessary to retrieve \code{x} again using \code{\link[=get_obj]{get_obj()}}. An already existing pin named \code{id} will be silently overwritten.}

\item{qs_preset}{The serialization algorithm preset to use. See \code{\link[qs:qsave]{qs::qsave()}} (section \emph{Presets}) for details.}
}
\value{
\code{x}, invisibly.
}
\description{
Stores an object in \code{pkg}'s user-cache pins board, i.e. caches it to the filesystem.
}
\details{
Note that \code{cache_obj()} will always overwrite an already existing cached object of the same \code{id}. See \code{\link[=hash_fn_call]{hash_fn_call()}} for a convenient way to create an \code{id}
that uniquely identifies a function call. Or just use \code{\link[=with_cache]{with_cache()}} that internally relies on the former.

Note that reading in the cached result from the user-cache pins board (i.e. from the filesystem) might produce a noticeable delay depending on the size of
the cached object. Therefore, it's only recommended to cache results that take a considerable amount of time to recompute. To avoid the overhead of
re-reading a cached result when accessing it multiple times, you can always assign it to an R variable to benefit from direct storage in memory.
}
\examples{
# if the fn below would be part of a real package, we could instead define `this_pkg` globally
# using `this_pkg <- utils::packageName()`; instead, we now cache to pkgpins's cache (which
# itself never uses the cache)
board <- pkgpins::board(pkg = "pkgpins")

# let's define a fn that returns R pkg sys deps from cache
pkg_sys_deps <- function(pkg,
                         use_cache = TRUE,
                         cache_lifespan = "6h") {
  fetch <- TRUE

  if (use_cache) {
    pin_name <- pkgpins::hash_fn_call(from_fn = "pkg_sys_deps",
                                      pkg)
    result <- pkgpins::get_obj(board = board,
                               id = pin_name,
                               max_age = cache_lifespan)
    fetch <- is.null(result)
  }
  
  if (fetch) {
    result <-
      jsonlite::fromJSON(txt = paste0("https://sysreqs.r-hub.io/pkg/", pkg),
                         simplifyVector = FALSE) |>
      purrr::list_flatten()
  }
 
  if (use_cache && fetch) {
    pkgpins::cache_obj(board = board,
                       x = result,
                       id = pin_name)
  }

  result
}

# now get the sys deps for git2r for the first time (populating the cache)
pkg_sys_deps("git2r")

\dontrun{
# for the `cache_lifespan` (we've set a default of 6h), the cached result will be returned
# (as long as `use_cache = TRUE`):
bench::mark("with cache" = pkg_sys_deps("git2r"),
            "without cache" = pkg_sys_deps("git2r", use_cache = FALSE),
            iterations = 10,
            relative = TRUE)}

# purge cache from the above example
pkgpins::purge_cache(board = board)
}
\seealso{
Other object handling functions:
\code{\link{get_obj}()},
\code{\link{hash_fn_call}()},
\code{\link{is_cached}()},
\code{\link{rm_obj}()}
}
\concept{obj_handling}
