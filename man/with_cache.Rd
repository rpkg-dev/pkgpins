% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pkgpins.gen.R
\name{with_cache}
\alias{with_cache}
\title{Cache the result of an expression}
\usage{
with_cache(
  expr,
  pkg,
  from_fn,
  ...,
  pkg_versioned = TRUE,
  use_cache = TRUE,
  cache_lifespan = "1 day"
)
}
\arguments{
\item{expr}{Expression to cache.}

\item{pkg}{Package name. A character scalar.}

\item{from_fn}{Name of the function that \code{expr} is cached from, i.e. the name of the function that \code{with_cache()} is called from. A character scalar.}

\item{...}{Arguments received by \code{from_fn} on which the caching should depend. This is fundamental to determine whether \code{expr} was already cached or not. The
arguments must be specified \emph{unnamed} (see examples). \link[rlang:dyn-dots]{Dynamic dots} are supported.}

\item{pkg_versioned}{Whether or not to make the caching dependent on the version number of \code{pkg}. If \code{FALSE}, caching is agnostic about \code{pkg}'s version
number. Otherwise, a separate user-cache pins board is created each time \code{pkg}'s version number changes (e.g. after an upgrade), ensuring to never return
cached results from a different (old) package version, irrespective of \code{cache_lifespan}.}

\item{use_cache}{Return cached results if possible. If \code{FALSE}, results are always newly fetched regardless of \code{cache_lifespan}.}

\item{cache_lifespan}{The duration after which cached results are refreshed (i.e. newly fetched). A valid \link[lubridate:as.duration]{lubridate duration}. Only relevant if \code{use_cache = TRUE}.}
}
\value{
The result of evaluating \code{expr}, from cache if \code{use_cache = TRUE} and a cached result exists that hasn't exceeded \code{cache_lifespan}.
}
\description{
One-stop solution to add caching to any R expression, for example from within a function. See the examples.
}
\details{
\code{expr} is evaluated in the environment that \code{with_cache()} is called from.

See \code{\link[=hash_fn_call]{hash_fn_call()}} for details about how the pin name is constructed that uniquely identifies \code{expr} in the \code{pkg}'s user-cache pins board.
}
\examples{
# if the fn below would be part of a real package, we could instead define `this_pkg` globally
# using `this_pkg <- utils::packageName()`; instead, we now cache to pkgpins's cache (which
# itself never uses the cache)
this_pkg <- "pkgpins"

# let's define a fn that returns R pkg sys deps from cache
pkg_sys_deps <- function(pkg,
                         use_cache = TRUE,
                         cache_lifespan = "6h") {
  pkgpins::with_cache(
    expr = purrr::flatten(jsonlite::fromJSON(txt = paste0("https://sysreqs.r-hub.io/pkg/", pkg),
                                             simplifyVector = FALSE)),
    pkg = this_pkg,
    from_fn = "pkg_sys_deps",
    pkg,
    use_cache = use_cache,
    cache_lifespan = cache_lifespan
  )
}

# now get the sys deps for git2r for the first time (populating the cache)
pkg_sys_deps("git2r")

\dontrun{
# for the `cache_lifespan` (we've set a default of 6h), the cached result will be returned
# (as long as `use_cache = TRUE`):
bench::mark("with cache" = pkg_sys_deps("git2r"),
            "without cache" = pkg_sys_deps("git2r", use_cache = FALSE),
            iterations = 10,
            relative = TRUE)}

# purge cache from the above example
pkgpins::board(pkg = "pkgpins") |> pkgpins::purge_cache()
}
\concept{high_lvl}
