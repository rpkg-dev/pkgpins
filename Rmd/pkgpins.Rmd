---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "cached",
                                 "id",
                                 "name"))
```

# Register a package's user-cache pins board

```{r}
#' Register a package's user-cache pins board
#'
#' This function registers a package's user-cache pins board. It will be automatically called when needed.
#'
#' @inheritParams boardname
#' @export
#'
#' @examples
#' \dontrun{
#' # you could register the cache on package load, although this isn't really necessary
#' .onLoad <- function(libname, pkgname) {
#'   pkgpins::register(pkgname)
#' }
#' }
register <- function(pkg) {
  
  if (!(boardname(pkg) %in% pins::board_list())) {
    
    pins::board_register_local(name = boardname(pkg),
                               cache = pins::board_cache_path(),
                               versions = FALSE)
  }
}
```

# Unregister a package's user-cache pins board

```{r}
#' Deregister a package's user-cache pins board
#'
#' This function deregisters a package's user-cache pins board.
#'
#' Ideally, you call this function on [package unload][base::.onUnload]. See the examples for details.
#'
#' @inheritParams boardname
#' @export
#'
#' @examples
#' \dontrun{
#' # deregister the cache on package unload
#' .onUnload <- function(libpath) {
#'   pkgpins::deregister()
#' }
#' }
deregister <- function(pkg) {
  
  if (boardname(pkg) %in% pins::board_list()) {
    
    pins::board_deregister(name = boardname(pkg))
  }
}
```

# Get a package's user-cache pins board name

By convention, the pins board name is identical to the directory name.

```{r}
#' Get a package's user-cache pins board name
#'
#' This function returns the board name of the `pks`'s user-cache pins board. 
#' 
#' It shouldn't be necessary to rely on this function for the tasks this package is intended to perform, though.
#'
#' @param pkg Package name. A character scalar.
#' @return The board name of the [user-cache pins board](https://pins.rstudio.com/articles/boards-understanding.html) belonging to `pkg`, which is at the same
#'   the name of the filesystem directory beneath [pkgpins::path_cache()]. A character scalar.
#' @export
boardname <- function(pkg) {
  
  paste0("pkg-cache-", checkmate::assert_string(pkg))
}
```

# Get a package's user-cache pins board path

```{r}
#' Get a package's user-cache pins board path
#'
#' This function allows to the determine the filesystem path to the `pkg`'s user-cache pins board. Note that this path depends on the operating system this
#' function is called from.
#' 
#' It shouldn't be necessary to rely on this function for the tasks this package is intended to perform, though.
#'
#' @inheritParams boardname
#' @return A path of type [fs_path][fs::path()].
#' @export
path_cache <- function(pkg) {
  
  fs::path(pins::board_cache_path(), boardname(pkg))
}
```

# List all objects in a package's user-cache pins board

```{r}
#' List all objects in a package's user-cache pins board
#'
#' This function lists all object `id`s and the date and time they were `cached`.
#'
#' @inheritParams boardname
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
ls_cache <- function(pkg) {
  
  register(pkg = pkg)
  result <- pins::pin_find(board = boardname(pkg),
                           extended = TRUE)
  
  if ("cached" %in% colnames(result)) {
    result %<>% dplyr::transmute(id = name,
                                 cached = lubridate::as_datetime(cached))
  } else {
    result <- tibble::tibble(id = character(),
                             cached = lubridate::as_datetime(integer()))
  }
  
  result
}
```

# Delete all objects from a package's user-cache pins board exceeding a certain age

```{r}
#' Delete all objects from a package's user-cache pins board exceeding a certain age
#'
#' This function allows to clean up old caching left-overs. It could be called on package load/unload, for example.
#'
#' @inheritParams boardname
#' @param max_age The age above which cached objects will be deleted. A valid [lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours).
#'
#' @export
#'
#' @examples
#' \dontrun{
#' # delete all cached results that are older than 7 days at once on package load:
#' .onLoad <- function(libname, pkgname) {
#'   pkgpins::register()
#'   pkgpins::clear(max_age = "7 days")
#' }
#' }
clear <- function(max_age = "1 day",
                  pkg) {
  
  register(pkg = pkg)
  
  ls_cache(pkg) %>%
    dplyr::filter(lubridate::now() - cached > lubridate::as.duration(max_age)) %$%
    id %>%
    purrr::walk(.f = pins::pin_remove,
                board = boardname(pkg))
}
```

# Cache an object to a package's user-cache pins board

```{r}
#' Cache an object to a package's user-cache pins board
#'
#' This function stores an object in a package's user-cache pins board.
#' 
#' The exact date and time (UTC) of the pinning is stored as the additional metadata `cached` which is of type [integer][base::integer]. You can restore the
#' actual datetime using [`lubridate::as_datetime(cached)`][lubridate::as_datetime] (note that [pkgpins::ls_cache()] does this automatically).
#'
#' @inheritParams boardname
#' @param x An object, local file or remote URL to be cached.
#' @param id The pin name uniquely identifying `x` in the `pkg`'s user-cache pins board. A character scalar. Necessary to retrieve `x` again using
#'   [pkgpins::get_obj()]. An already existing pin named `id` will be silently overwritten.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' library(magrittr)
#' 
#' jsonlite::fromJSON(txt = "https://sysreqs.r-hub.io/pkg/git2r",
#'                    simplifyVector = FALSE) %>%
#'   purrr::flatten() %>%
#'   pkgpins::cache_obj(id = "git2r-syreqs")
#' }
cache_obj <- function(x,
                      id,
                      pkg) {
  
  register(pkg = pkg)
  
  pins::pin(x = x,
            board = boardname(pkg),
            name = checkmate::assert_string(id),
            metadata = list(cached = lubridate::now()))
}
```

# Get a cached object from a package's user-cache pins board

```{r}
#' Get a cached object from a package's user-cache pins board
#'
#' This function retrieves a cached object from a package's user-cache pins board _if_ it is not older than `max_age`.
#'
#' @inheritParams boardname
#' @param id The pin name uniquely identifying the object to be retrieved from the `pkg`'s user-cache pins board. A character scalar.
#' @param max_age The maximum age the cached object is allowed to have. A valid [lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours).
#'
#' @return The cached object if it is not older than `max_age`, otherwise `NULL`.
#' @export
#'
#' @examples
#' \dontrun{
#' pkgpins::get_obj(id = "git2r-syreqs",
#'                  max_age = "2 weeks")
#' }
get_obj <- function(id,
                    max_age = "1 day",
                    pkg) {
  
  register(pkg = pkg)
  board <- boardname(pkg)
  result <- pins::pin_find(name = checkmate::assert_string(id),
                           board = board,
                           extended = TRUE)
  
  if (nrow(result) > 1) {
    rlang::abort(paste0("Multiple pins found for board '", board, "'!\nThis should not happen since versioning is disabled for pkgpins boards... \U1F41E"))
    
  } else if (nrow(result) == 1) {
    
    if (!("cached" %in% colnames(result))) {
      rlang::abort(paste0("Corrupted package cache detected! Please delete the directory `", path_cache(pkg = pkg), "` and then try again."))
    }
    
    result %<>% dplyr::filter(lubridate::now() - lubridate::as_datetime(cached) <= lubridate::as.duration(max_age)) %$% name
    
    if (length(result) > 0) {
      result <- pins::pin_get(board = board,
                              name = id)
    } else{
      result <- NULL
    }
    
  } else {
    result <- NULL
  }
  
  result
}
```

# Delete a cached object from a package's user-cache pins board

```{r}
#' Delete a cached object from a package's user-cache pins board
#'
#' Note that it normally won't be necessary to delete a cached object using this function because [pkgpins::cache_obj()] will always overwrite a possibly
#' existing object in the cache with the same `id`. If you want to ensure that no "data corpses" are left behind from using [pkgpins::cache_obj()], consider
#' clearing the whole package user-cache pins board at once using [pkgpins::clear()].
#'
#' @inheritParams boardname
#' @param id The pin name uniquely identifying the object to be deleted from the `pkg`'s user-cache pins board. A character scalar.
#'
#' @export
#'
#' @examples
#' \dontrun{
#' pkgpins::rm_obj(id = "git2r-syreqs")
#' }
rm_obj <- function(id,
                   pkg) {
  
  register(pkg = pkg)
  
  pins::pin_remove(board = boardname(pkg),
                   name = checkmate::assert_string(id))
}
```

# Convert a function call to a (pin) name

```{r}
#' Convert a function call to a (pin) name
#'
#' This function strives to create a string that uniquely identifies a function call by the function name and the specified arguments. For example, the
#' function call `foo(a = F, b = "bar", c = 1)` will be converted to
#' `r foo <- function(a, b, c) call_to_name(); pal::prose_ls(foo(a = F, b = "bar", c = 1), wrap = '"')`.
#' 
#' This function does evaluate object names passed as function arguments. I.e. the function call `foo(a = my_var)`, where `my_var`'s value is `100`, will be
#' converted to `r my_var <- 100; pal::prose_ls(foo(100), wrap = '"')`.
#' 
#' Nevertheless, it should be used with caution since the name conversion can be destructive: For instance, whitespaces are just deleted, thus
#' `foo(a = "ho ho")` and `foo(a = paste("ho", "ho", sep = paste0(rep(" ", 5), collapse = "")))` both produce the name
#' `r pal::prose_ls(foo(a = paste("ho", "ho", sep = paste0(rep(" ", 5), collapse = ""))), wrap = '"')` by default. Set `rm_blanks = FALSE` in order to keep
#' whitespaces.
#' 
#' Also, characters which are problematic or have special meaning on common filesystems are removed by default. To prevent this, use `sanitize = FALSE`
#' instead.
#' 
#' Finally, `", "` in evaluated argument names will be replaced by `"-"` by default. See examples. Turn of all the known-to-be destructive conversion steps
#' at once by setting `non_destructive = TRUE`.
#'
#' @param call A [function call][base::call]. Defaults to the call of the calling function.
#' @param rm_blanks Remove all whitespaces from `call`'s evaluated argument names. Enabled by default.
#' @param sanitize Remove characters which are problematic or have special meaning on common filesystems from `call`'s evaluated argument names. Enabled by
#'   default. See [fs::path_sanitize()] for details about the performed sanitation.
#' @param non_destructive Disable all name conversion steps which are known to be destructive (loss of information). See details. This setting implies
#'   `santize = FALSE` and `rm_blanks = FALSE`. This is set to `FALSE` by default.
#' @param exclude_args Specify argument names to be excluded from the generated name. A character vector.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' foo <- function(a, b, c) call_to_name()
#' foo("ya", "hoo")
#'
#' # ", " in evaluated argument names will be replaced by "-"
#' # which means the following produces identical names
#' foo("", "ar", list("1, 77"))
#' foo("", "ar", list(1, 77))
#' 
#' # to avoid this and produce distinct names instead:
#' foo <- function(a, b, c) call_to_name(non_destructive = TRUE)
#' foo("", "ar", list("1, 77"))
#' foo("", "ar", list(1, 77))
#'
#' # exclude arguments by name
#' foo <- function(a, b, c) call_to_name(exclude_args = c("a", "c"))
#' foo("", "ar", list("1, 77"))
#' foo("", "ar", list(1, 77))
call_to_name <- function(call = match.call(definition = sys.function(sys.parent(1L)),
                                           call = sys.call(sys.parent(1L))),
                         rm_blanks = TRUE,
                         sanitize = TRUE,
                         non_destructive = FALSE,
                         exclude_args = NULL) {
  
  fun_name <- as.character(as.list(call)[1])
  args <- as.list(call[-1])
  
  if (!is.null(checkmate::assert_character(exclude_args,
                                           any.missing = FALSE,
                                           null.ok = TRUE))) {
    
    excl <- names(args) %in% exclude_args
    
    if (length(excl) > 0) {
      
      args <- args[!excl]
    }
  }
  
  if (length(args) > 0) {
    
    # evaluate the call's arguments in the calling environment
    args %>%
      purrr::map(.f = eval,
                 envir = sys.frame(1L)) %>%
      # convert to string
      # (don't really know if this could be a destructive conversion step under specific circumstances)
      deparse1() %>%
      # remove enclosing "list()"
      stringr::str_remove_all(pattern = "(^list\\(|\\)$)") %>%
      # replace whitespaces
      stringr::str_replace(pattern = "(^.+?), ",
                           replacement = "\\1_") %>%
      # (this is a potentially destructive conversion step)
      purrr::when(!non_destructive ~ stringr::str_replace_all(string = .,
                                                              pattern = ", ",
                                                              replacement = "-") ,
                  ~ .) %>%
      # remove " = " and quotes
      # (this is a potentially destructive conversion step)
      purrr::when(!non_destructive ~ stringr::str_remove_all(string = .,
                                                             pattern = "( = |[\"'])") ,
                  ~ .) %>%
      stringr::str_replace_all(pattern = dplyr::if_else(checkmate::assert_flag(rm_blanks),
                                                        "\\s+",
                                                        "^$"),
                               replacement = "") %>%
      # add function name
      paste0(fun_name, dplyr::if_else(nchar(.) > 0, "_", ""), .) %>%
      # remove filesystem-unsafe chars
      # (this is a potentially destructive conversion step)
      purrr::when(sanitize & !non_destructive ~ fs::path_sanitize(.),
                  ~ .)
  } else {
    
    fun_name
  }
}
```

# Get predefined parameter label

```{r}
#' Get predefined parameter label
#'
#' These are pre-defined labels intended to be used for parameters of the same name in `@param`
#' [roxygen2 tags](https://roxygen2.r-lib.org/articles/rd.html#functions).
#'
#' Recommended usage in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' ``@@param cache_lifespan `r pkgpins::param_label("cache_lifespan")` ``  
#' ``@@param use_cache `r pkgpins::param_label("use_cache")` ``
#'
#' @param name The label name.
#'
#' @return A character scalar.
#' @export
param_label <- function(name = c("cache_lifespan",
                                 "use_cache")) {
  
  rlang::arg_match(name) %>%
    switch(cache_lifespan = paste0("The duration after which cached results are refreshed (i.e. newly fetched). A valid ",
                                   "[lubridate duration][lubridate::as.duration]. Defaults to 1 day (24 hours). Only relevant if `use_cache = TRUE`."),
           
           use_cache = "Return cached results if possible. If `FALSE`, results are always newly fetched regardless of `cache_lifespan`."
    )
}
```
